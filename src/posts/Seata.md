---
title: Seata
description: Seata的概念介绍、基本使用
---
## Seata是什么？
Spring中内置了关于事务的功能，只要对方法使用注解`@Transactional`就能让方法内的操作要么全部执行、要么全部失败，即保证该方法的原子性。但是Spring内置的事务功能是在单体应用下使用的，如果是分布式架构？
试想这样一种情况：在一个方法中使用了两个远程调用函数，我们需要这样两个位于不同服务器的服务要么全部成功、要么全部失败，这时候该如何做呢？Seata中提供了注解`@GlobalTransactional`注解，和Spring中的注解类似，只需要对这个方法使用`@GlobalTransactional`注解就可以实现分布式下的事务啦！

当然，真实的情况不会是只添加一个注解那么简单，还需要一系列的配置。不过Seata确实提供了一种很方便的分布式事务的解决方案，那么Seata是如何做到的呢？

## Seata原理
Seata提供了四种事务模式来解决上述问题，这里讲最常用的`AT`模式。AT模式是二阶段提交（2 Phase Commit， 2PC）的一种改良，我们先来看下二阶段提交是什么。
二阶段提交最早是包含在`X/Open`组织提出的一套XA的事务处理架构中的，XA将事务分为两个阶段：*准备阶段*和*提交阶段*。
二阶段提交引入了两个概念：`参与者（RM）`和`协调者（TC）`，每个参与者在执行本地事务后，不会立马提交，它们会先做一份undo日志（方便回滚），然后去请求tc，看tc是批准提交还是回滚。TC这边呢，会收到它管理的所有参与者的信息，如果所有参与者都准备好了，那就向所有参与者发出提交命令，如果任何一个参与者出错了，就向所有参与者发出回滚命令。

AT模式对上述过程有一定的改造，AT引入了一个`全局锁`，参与者在执行完SQL操作后就会请求全局锁，拿到全局锁后，才提交本地事务，拿不到全局锁就不能提交本地事务，就需要一直请求全局锁，如果请求全局锁超时就回滚。第二阶段的行为和2PC的第二阶段区别不大，只是把提交都做成异步的了，能够减少tc与rm的通信时间。
整体的流程图参考下图：
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20230214221541.png)

## Seata中AT模式的缺点
由于AT模式拦截了SQL，Seata为我们自动生成了undo和redo日志，这样的过程破坏了SQL执行的原子性。
如果没有全局锁的话，AT模式中有风险的地方在于，在提交本地事务之后，在完成全局事务之前，如果该数据被其他其他操作修改过（脏写），这时候一旦需要回滚，就不能用自动生成的逆向SQL补偿了。但加入全局锁之后肯定是会牺牲性能的。

Seata的默认隔离级别是“读未提交”的，脏读无法避免有时候是致命的。Seata通过代理`select ... for update`来避免脏读，方式还是使用全局锁，即只有获取唯一的全局锁才能读取数据，但对读操作采用全局锁，会让性能下降很多。