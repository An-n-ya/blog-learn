---
title: 低代码开发平台（三） 
description: 分析JeecgBoot的菜单功能
---
在用户登录之后，我们需要根据用户的角色展示相应的页面。
### 动态配置路由
在`vue-router`中是可以动态配置路由的，可以通过`Router.addRoute()`方法动态添加路由（这里的Router由CreateRouter创建，在JeecgBoot项目里，这个对象由`src/router/index.ts`创建并暴露出来），注意这里`addRoute`接受的参数为`RouteRecordRaw`这个类型，这个类型定义在`vue-router.d.ts`里：
```ts
export declare type RouteRecordRaw = RouteRecordSingleView | RouteRecordSingleViewWithChildren | RouteRecordMultipleViews | RouteRecordMultipleViewsWithChildren | RouteRecordRedirect
```
详细的对象内容可以参考[官方文档](https://router.vuejs.org/zh/api/#routerecordraw)

在*低代码开发平台（三）*中，我们提到了在前端发送登录请求成功后，会处理`afterLoginAction`逻辑，在这个方法中会向后端请求路由信息: `const routes = await permissionStore.buildRoutesAction()`，这里依旧用的是piana中的action，这样可以方便存放全局信息，在这个action里有这么一行代码:`routeList = (await getMenuList()) as AppRouteRecordRaw[]`，这个就是向后端请求routes的请求代码了：
```ts
export const getMenuList = () => {
  return new Promise((resolve) => {
    //为了兼容mock和接口数据
    defHttp.get<getMenuListResultModel>({ url: Api.GetMenuList }).then((res) => {
      if (Array.isArray(res)) {
        resolve(res);
      } else {
        resolve(res['menu']);
      }
    });
  });
}
```
最后得到的是一个routes数组，每个routes直接通过`Router.addRoute()`方法加到路由中去，这要求后端的存储格式必须和前端vue-router要求的一直，即必须和`RouteRecordRaw`一致。我们去看下后端是如何实现的：

### 系统授权逻辑
前端的路由信息存储在后端，后端这个是通过`/sys/getUserPermissionByToken`这个接口暴露对应资源的。这个接口最后会给出四个资源：路由菜单权限、按钮权限、全部权限配置集合、是否是安全模式。这个接口只请求了一张表，这个表里就包含了上面的所有四种信息，这个表一共有27列：
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20230205154939.png)
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20230205155035.png)
是典型的字典树结构。这个表把四种信息混杂在一起，大部分的数据是菜单路由信息，像第2行这样的就是按钮权限，还有一些是外链。
请求到这些数据后，会调用`private void getPermissionJsonArray(JSONArray jsonArray, List<SysPermission> metaList, JSONObject parentJson) `方法和`private JSONObject getPermissionJsonObject(SysPermission permission) `方法将这些数据处理成树型json结构方便前端使用，其中前者处理数组，后者处理对象。这个转换的逻辑写得不是很好，它是在一个递归结构里遍历每一个metaList，复杂度为`O(N^2)`，其实这个逻辑可以通过使用哈希表让时间复杂度降到`O(N)`，不过`sys_permission`这张表的数据量并不大，所以用`O(N^2)`的复杂度问题不大。
另外，我觉得这样的json数据结构更适合使用MongoDB存储，但考虑到这样会给整个系统再添加一个依赖，会让部署难度进一步提高，可能是出于降低入手门槛选择了这样的数据结构吧。

### 前端导航配置
前端这边仅获得了路由配置还不够，还需要配置一下导航栏。 