---
title: 微服务流量治理的原理以及实现
description: 探索微服务中流量治理的原理以及实现
---

我们家中常常会安装一个“保险丝”的器件，当家里电器功率过高超过了屋内线路能承受的功率时，保险丝就会==熔断==导致供电中断，从而保护屋内电器。
在微服务中也有类似的情况，如果某个接口访问量过大（过多人排队），可能会让系统进入资源竞争状态，这可能会降低整个系统的吞吐量。还有一种常见的情况是这样的，我们的计算资源往往来自云服务提供商，这些计算资源往往是按量计费的，如果有用户恶意请求接口，可能会让计算资源白白浪费、给服务提供者带来直接的经济损失，在使用云服务商服务的时候加服务限流还是很有必要的。

[Sentinel](https://github.com/alibaba/Sentinel)是阿里开源的流量治理组件，Sentinel可以提供流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等功能，Sentinel可以方便的介入各种分布式架构的系统中，Sentinel还提供了SPI机制让用户可以方便的定义自己的流量治理插件。

## Sentinel在Spring Cloud中的基本使用
1. 引入Sentinel依赖
```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```
2. 使用`@SentinelResource`表示资源，从而让Sentinel对这些资源进行流量治理
```java
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(ServiceApplication.class, args);
    }
}

@Service
public class TestService {

    @SentinelResource(value = "sayHello")
    public String sayHello(String name) {
        return "Hello, " + name;
    }
}

@RestController
public class TestController {

    @Autowired
    private TestService service;

    @GetMapping(value = "/hello/{name}")
    public String apiHello(@PathVariable String name) {
        return service.sayHello(name);
    }
}
```
3. 设置治理规则
我们可以通过[sentinel dashboard](https://sentinelguard.io/zh-cn/docs/dashboard.html)以图形化的方式设置规则，也可以用代码控制，这里用代码演示：
```java
public class FlowRuleInitFunc implements InitFunc {
    @Override
    public void init() throws Exception() {
        List<DegradeRule> rules = new ArrayList<>();
        DegradeRule rule = new DegradeRule(resource)
            .setGrade(CircuitBreakerStrategy.ERROR_RATIO.getType())
            .setCount(0.7) // Threshold is 70% error ratio
            .setMinRequestAmount(100)
            .setStatIntervalMs(30000) // 30s
            .setTimeWindow(10);
        rules.add(rule);
        DegradeRuleManager.loadRules(rules);
    }
}
```
然后在 `resource` 目录下创建 `META-INF/services/com.alibaba.csp.sentinel.init.InitFunc`文件，在文件里加入类 `FlowRuleInitFunc` 的类名全路径比如 `host.ankh.xxx.FlowRuleInitFunc`。设置完毕后，Sentinel会利用SPI机制加载所有的InitFunc并执行他们的init方法，到时候就会把这里定义的rule添加进去了。
这里配置的是一个降级规则，降级规则的属性可以参考下表：
|Field| 	说明|    	默认值|
|-----|--------|-------|
|resource| 	资源名，即规则的作用对象 |	|
|grade| 	熔断策略，支持慢调用比例/异常比例/异常数策略| 	慢调用比例|
|count |	慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例/异常数模式下为对应的阈值| | 	
|timeWindow| 	熔断时长，单位为 s 	| |
|minRequestAmount| 	熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）| 	5|
|statIntervalMs |	统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）| 	1000 ms|
|slowRatioThreshold| 	慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入） 	| |

更多的规则请参考[官方文档](https://sentinelguard.io/zh-cn/docs/basic-api-resource-rule.html)

## Sentinel接入Spring Cloud的过程
首先还是看`spring-cloud-starter-alibaba-sentinel`包下的`spring.factories`：
```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.alibaba.cloud.sentinel.SentinelWebAutoConfiguration,\
com.alibaba.cloud.sentinel.SentinelWebFluxAutoConfiguration,\
com.alibaba.cloud.sentinel.endpoint.SentinelEndpointAutoConfiguration,\
com.alibaba.cloud.sentinel.custom.SentinelAutoConfiguration,\
com.alibaba.cloud.sentinel.feign.SentinelFeignAutoConfiguration

org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker=\
com.alibaba.cloud.sentinel.custom.SentinelCircuitBreakerConfiguration
```
其中有针对各种web框架的自动配置类，我们就看最基础的`SentinelWebAutoConfiguration`。这个自动配置类会注入一个`SentinelWebInterceptor`的Bean，这个Bean继承自`AbstractSentinelInterceptor`，而`AbstractSentinelInterceptor`实现了Spring MVC的`HandlerInterceptor`接口，因此在每个请求转发到对应的Controller之前都会经过这个interceptor，它的preHandle定义如下：
```java
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    try {
        String resourceName = this.getResourceName(request);
        if (StringUtil.isEmpty(resourceName)) {
            return true;
        } else if (this.increaseReferece(request, this.baseWebMvcConfig.getRequestRefName(), 1) != 1) {
            return true;
        } else {
            String origin = this.parseOrigin(request);
            String contextName = this.getContextName(request);
            ContextUtil.enter(contextName, origin);
            Entry entry = SphU.entry(resourceName, 1, EntryType.IN);
            request.setAttribute(this.baseWebMvcConfig.getRequestAttributeName(), entry);
            return true;
        }
    } catch (BlockException var12) {
        BlockException e = var12;

        try {
            this.handleBlockException(request, response, e);
        } finally {
            ContextUtil.exit();
        }

        return false;
    }
}
```
最关键的是这一句`Entry entry = SphU.entry(resourceName, 1, EntryType.IN);`，`SphU`是Sentinel的API，调用这个方法后Sentinel就对这个请求开启了流量治理。至此就完成了Sentinel和Spring Cloud的对接。

## Sentinel中的SphU
`SphU`的entry会调用`Sph`（这是一个接口）的entry方法，而Sentinel中`Sph`的唯一实现类是`CtSph`（不得不说Sentinel的方法名确实有点奇怪，不知道啥意思...），这个类的entry方法最终会调用到本类的`entryWithPriority`方法，我们需要关注这个类的`entryWithPriority`方法：
```java
private Entry entryWithPriority(ResourceWrapper resourceWrapper, int count, boolean prioritized, Object... args)
    throws BlockException {
    Context context = ContextUtil.getContext();
    ProcessorSlot<Object> chain = lookProcessChain(resourceWrapper);

    Entry e = new CtEntry(resourceWrapper, chain, context);
    chain.entry(context, resourceWrapper, null, count, prioritized, args);
    return e;
}
```
这里创建了一个`chain`，我们可以大胆猜测Sentinel使用了责任链模式，通过在责任链上添加功能实现流量治理。我们点开`lookProcessChain`发现里边使用了`SlotChainProvider.newSlotChain()`创建了一个chain，这个chain最终来自于`DefaultSlotChainBuilder`的build方法，我们看下这个方法：
```java
    public ProcessorSlotChain build() {
        ProcessorSlotChain chain = new DefaultProcessorSlotChain();

        List<ProcessorSlot> sortedSlotList = SpiLoader.of(ProcessorSlot.class).loadInstanceListSorted();
        for (ProcessorSlot slot : sortedSlotList) {
            if (!(slot instanceof AbstractLinkedProcessorSlot)) {
                RecordLog.warn("The ProcessorSlot(" + slot.getClass().getCanonicalName() + ") is not an instance of AbstractLinkedProcessorSlot, can't be added into ProcessorSlotChain");
                continue;
            }

            chain.addLast((AbstractLinkedProcessorSlot<?>) slot);
        }

        return chain;
    }
```
这个方法通过SPI机制加载了所有的`ProcessorSlot`，并把这个Slot添加到默认的chain中。在`sentinel-core/src/main/resources/META-INF/services/com.alibaba.csp.sentinel.slotchain.ProcessorSlot`中可以找到SPI具体需要加载的类：
```properties
com.alibaba.csp.sentinel.slots.nodeselector.NodeSelectorSlot
com.alibaba.csp.sentinel.slots.clusterbuilder.ClusterBuilderSlot
com.alibaba.csp.sentinel.slots.logger.LogSlot
com.alibaba.csp.sentinel.slots.statistic.StatisticSlot
com.alibaba.csp.sentinel.slots.block.authority.AuthoritySlot
com.alibaba.csp.sentinel.slots.system.SystemSlot
com.alibaba.csp.sentinel.slots.block.flow.FlowSlot
com.alibaba.csp.sentinel.slots.block.degrade.DegradeSlot
com.alibaba.csp.sentinel.slots.block.degrade.DefaultCircuitBreakerSlot
```
这里边的就是默认的9个Slot。这些Slot有什么作用呢，这就得说起Sentinel的工作流程了。

## Sentinel的工作主流程
Sentinel官方给出的工作流程图如下：
![](https://sentinelguard.io/docs/zh-cn/img/sentinel-slot-chain-architecture.png)
整个Sentinel就是在一条责任链上执行，链上有一个个的Slot完成各自的工作，责任链中默认就是上一小节中提到的9个Slot，前三个Slot`NodeSelectorSlot`，`ClusterBuilderSlot`，`StatisticSlot`在流程图里有详细的图示，它们是Sentinel的基础。
- NodeSelectorSlot 用于把所有的“资源”组织成一棵树
- ClusterBuilderSlot 用于构建资源的唯一标识`clusterNode`
- StatisticSlot 用于统计流量信息

我们接下来重点关注`StatisticSlot`和`FlowSlot`的实现，来看看Sentinel是如何统计流量并且进行流量控制的。

### StatisticSlot的实现


### FlowSlot的实现