---
title: 服务发现的原理以及实现
description: 探索为什么需要服务发现，服务发现的实现原理，以及如何使用etcd实现一个注册中心
---
## 什么是服务发现？
在微服务架构下，节点数量巨大，节点“网络位置”不固定，这会让远程调用难以维护。这时候我们就可以通过服务发现与所有其他节点打交道，我们只需要一个固定的“服务名”就能访问到需要的服务，而不用关心服务的位置。
除此之外，服务发现还可以提供确保服务健康这样的功能。

我们发现微服务中的每个服务都会依赖服务发现节点（这一点和注册中心的位置相似，因此nacos就把这两个功能放到一起了），这样的话服务发现节点的压力会很大。一个常见的解决方案是部署服务发现集群，保证集群内所有服务发现节点存储相同的数据，再使用一个负载均衡器平分每个节点的负载压力。这样子的话就不得不面对CAP的抉择，即集群内所有数据的一致性更重要还是集群的可用性更重要。

## 服务发现的实现
从上面的描述中可以发现服务发现实现的功能类似于一个查表操作，即使用某个“标识符”查找它对应的ip地址+端口号。那么我们可以使用一个K/V架构去实现。如果是单体服务发现，我们当然可以用Redis来实现服务发现，甚至可以直接用一个`HashMap`来实现。

但是现实是我们往往会部署很多服务发现节点，因此我们需要的是一个分布式架构的K/V框架。ZooKeeper、etcd都提供了这样的K/V框架，通过共识算法保证数据一致性和高可用性。ZooKeeper实现比较复杂，etcd实现更加简洁一些（Raft算法的Go语言实现），我们重点看下etcd的如何实现一个服务发现功能。

### 使用etcd实现服务注册




## 参考资料
- etcd api文档  https://etcd.io/docs/v3.6/learning/api/
- jetcd https://g
- etcd实现服务发现（Go语言版） https://juejin.cn/post/7101947466722836487
- etcd实现服务发现（Java版） https://blog.csdn.net/weixin_39510813/article/details/117671247
- gRPC https://grpc.io/docs/languages/java/quickstart/
