---
title: 微服务里网关的原理以及实现
description: 探索为什么需要网关、网关的实现原理，顺带介绍Java里的无阻塞IO与Netty
---
网关位于整个微服务架构的最前端，用来连接用户端与服务端，即通过网关把内网的服务暴露出去供外网用户访问，这样一来网关就是整个服务系统的必经之路，所有用户必须通过这个组件访问内网服务，这就对网关的性能提出了很高的要求。
对Java微服务技术栈来说，常用的网关有Netflix的Zuul还有Spring自家的Spring Cloud Config，Zuul 1.0使用的是阻塞IO，性能比较差，而且现在也没有维护了，Zuul 2.0虽然性能有提升，但是Spring Cloud做出了自家的网关（通过后面的内容会发现Spring确实很适合自己做一个网关），所以现在Spring Cloud Config反而更受欢迎，因此这篇文章会重点研究Spring Cloud Config。

网关作为整个系统的门面，虽然主要职责是转发请求，但由于需要对接各个系统，网关需要具备以下功能：
- 高性能
- 能够与注册中心对接，将外部流量转发给注册中心提供的地址
- 能够与流量控制组件对接，需要对某些访问做熔断、流量降级
- 能支持各种各样的协议，比如http、ws、QUIC，或者是各种RPC协议
- 能够与配置中心对接，路由转发规则能通过配置中心获取

总体来说，网关本身实现的功能并不复杂，但由于需要对接大量微服务组件，所以需要具备很好的扩展性，最重要的是网关必须能够处理高并发，这对网关组件的架构提出了很高的要求，那么Spring Cloud Config是如何设计的呢？我们带着这个问题去看看Spring Cloud Config的源码。


网关作为一个微服务组件，其本身就是一个Spring Boot应用，在Spring Cloud Config的源码中，网关的代码逻辑在`spring-cloud-gateway-server`子包中，点开发现这个包并不是一个Spring MVC结构的，事实上这个项目是一个典型的Reactive Stack的项目结构，Reactive Stack是Spring 5主推的响应式web结构，它提供了NIO的web编程框架，能够更好的应对高并发的场景：
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20230305162620.png)

我们在研究Spring Cloud Config源码之前先介绍下NIO与Reactor模式这方面的知识，弄清楚了这些基本知识再看源码会更轻松。


## NIO
熟悉UNIX网络编程的朋友可能会知道，在UNIX/LINUX体系下有五种网络编程模型：
- 阻塞IO：在程序（一个线程）调用网络IO的系统调用后就阻塞在这里，直到网络IO拿到数据并返回，程序才继续执行（这是最常见、最简单的IO模式）
- 非阻塞IO：在程序（一个线程）调用网络IO后立马返回，然后每隔一段时间就向内核询问数据是否准备好，如果没有准备好，这个线程由于没有被阻塞，所以可以被其他线程换出，从而更好的利用处理器的多核架构
- 非阻塞IO复用模型：第二种方案听起来是不错，但是线程需要时不时地询问内核，其实工作效率并不算高，于是就有了`epoll`或是`kqueue`这样的系统统调用，能够同时监听多个网络IO（在Linux下网络IO就是用文件描述符表示的：file descriptor, fd）是否准备好，当有fd准备好，就调用对应的回调函数。这里有两点重要改变：1. 只需要少量线程（运行select或epoll的线程）就可以处理大量线程的网络IO 2. 使用事件驱动的模式，在需要的时候调用回调函数
- 信号驱动模型：程序使用sigaction这样的系统调用，让内核在网络数据到达后发送信号给程序，这样的话，程序只需要实现建立对应信号的处理函数就好了，在收到信号后处理函数里的逻辑便可以工作了，处理函数中需要做的第一件事就是从内核的缓冲区中取出网络数据（这是一次
从内核空间到用户空间的数据传递，阻塞IO、非阻塞IO、非阻塞IO复用模型、信号驱动模型都需要这一步）
- 异步IO：这种方式和信号驱动模型很相似，只不过内核把“复制缓冲区数据到用户空间”这一步也帮用户做了，这时候用户程序只需要消费数据即可

上面几种模型可以用食堂打菜类比，阻塞IO就是打菜的时候食物没做好，就在那里干等；非阻塞IO就是在没做好的时候去做别的事情（刷刷手机、聊聊天啥的），然后过一段时间去问问饭菜做好了没；非阻塞IO复用模型就是在第二个的基础上帮舍友去打饭，这样整个宿舍只需要一个人去打菜就可以了，其他人可以做自己的事情；信号驱动模型就是做饭的厨师和你很熟，他把饭做好了会直接打电话通知你，你只需要去食堂取就可以了；异步IO就是点外卖，饭菜直接送到门口，都不需要去取了。

看起来异步IO最高效，但由于Linux内核的异步IO一直不是很稳定，所以真正使用异步IO模型的服务器并不多，大多数服务器通常是使用IO复用模型（比如Nginx、Jetty）。


## Reactor模式 背压 back pressure


## Reactive Stream


### 粘包与拆包


## Netty


## Servlet 3.1 异步 container


## WebFlux

