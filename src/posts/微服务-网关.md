---
title: 微服务里网关的原理以及实现
description: 探索为什么需要网关、网关的实现原理，顺带介绍Java里的无阻塞IO与Netty
---
网关位于整个微服务架构的最前端，用来连接用户端与服务端，即通过网关把内网的服务暴露出去供外网用户访问，这样一来网关就是整个服务系统的必经之路，所有用户必须通过这个组件访问内网服务，这就对网关的性能提出了很高的要求。
对Java微服务技术栈来说，常用的网关有Netflix的Zuul还有Spring自家的Spring Cloud Gateway，Zuul 1.0使用的是阻塞IO，性能比较差，而且现在也没有维护了，Zuul 2.0虽然性能有提升，但是Spring Cloud做出了自家的网关（通过后面的内容会发现Spring确实很适合自己做一个网关），所以现在Spring Cloud Gateway反而更受欢迎，因此这篇文章会重点研究Spring Cloud Gateway。

网关作为整个系统的门面，虽然主要职责是转发请求，但由于需要对接各个系统，网关需要具备以下功能：
- 高性能
- 能够与注册中心对接，将外部流量转发给注册中心提供的地址
- 能够与流量控制组件对接，需要对某些访问做熔断、流量降级
- 能支持各种各样的协议，比如http、ws、QUIC，或者是各种RPC协议
- 能够与配置中心对接，路由转发规则能通过配置中心获取

总体来说，网关本身实现的功能并不复杂，但由于需要对接大量微服务组件，所以需要具备很好的扩展性，最重要的是网关必须能够处理高并发，这对网关组件的架构提出了很高的要求，那么Spring Cloud Gateway是如何设计的呢？我们带着这个问题去看看Spring Cloud Gateway的源码。


网关作为一个微服务组件，其本身就是一个Spring Boot应用，在Spring Cloud Gateway的源码中，网关的代码逻辑在`spring-cloud-gateway-server`子包中，点开发现这个包并不是一个Spring MVC结构的，事实上这个项目是一个典型的Reactive Stack的项目结构，Reactive Stack是Spring 5主推的响应式web结构，它提供了NIO的web编程框架，能够更好的应对高并发的场景：
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20230305162620.png)

我们在研究Spring Cloud Gateway源码之前先介绍下NIO与Reactor模式这方面的知识，弄清楚了这些基本知识再看源码会更轻松。


## NIO
熟悉UNIX网络编程的朋友可能会知道，在UNIX/LINUX体系下有五种网络编程模型：
- 阻塞IO：在程序（一个线程）调用网络IO的系统调用后就阻塞在这里，直到网络IO拿到数据并返回，程序才继续执行（这是最常见、最简单的IO模式）
- 非阻塞IO：在程序（一个线程）调用网络IO后立马返回，然后每隔一段时间就向内核询问数据是否准备好，如果没有准备好，这个线程由于没有被阻塞，所以可以被其他线程换出，从而更好的利用处理器的多核架构
- 非阻塞IO复用模型：第二种方案听起来是不错，但是线程需要时不时地询问内核，其实工作效率并不算高，于是就有了`epoll`或是`kqueue`这样的系统统调用，能够同时监听多个网络IO（在Linux下网络IO就是用文件描述符表示的：file descriptor, fd）是否准备好，当有fd准备好，就调用对应的回调函数。这里有两点重要改变：1. 只需要少量线程（运行select或epoll的线程）就可以处理大量线程的网络IO 2. 使用事件驱动的模式，在需要的时候调用回调函数
- 信号驱动模型：程序使用sigaction这样的系统调用，让内核在网络数据到达后发送信号给程序，这样的话，程序只需要实现建立对应信号的处理函数就好了，在收到信号后处理函数里的逻辑便可以工作了，处理函数中需要做的第一件事就是从内核的缓冲区中取出网络数据（这是一次
从内核空间到用户空间的数据传递，阻塞IO、非阻塞IO、非阻塞IO复用模型、信号驱动模型都需要这一步）
- 异步IO：这种方式和信号驱动模型很相似，只不过内核把“复制缓冲区数据到用户空间”这一步也帮用户做了，这时候用户程序只需要消费数据即可

上面几种模型可以用食堂打菜类比，阻塞IO就是打菜的时候食物没做好，就在那里干等；非阻塞IO就是在没做好的时候去做别的事情（刷刷手机、聊聊天啥的），然后过一段时间去问问饭菜做好了没；非阻塞IO复用模型就是在第二个的基础上帮舍友去打饭，这样整个宿舍只需要一个人去打菜就可以了，其他人可以做自己的事情；信号驱动模型就是做饭的厨师和你很熟，他把饭做好了会直接打电话通知你，你只需要去食堂取就可以了；异步IO就是点外卖，饭菜直接送到门口，都不需要去取了。

看起来异步IO最高效，但由于Linux内核的异步IO一直不是很稳定，所以真正使用异步IO模型的服务器并不多，大多数服务器通常是使用IO复用模型（比如Nginx、Jetty）。


## Reactor模式
上面介绍了非阻塞IO的好处，但关于非阻塞IO的程序却十分难以编写，因为函数的调用并不是从上往下顺序执行，这个通常的程序有很大的区别，而且在非阻塞IO编程中往往会遇到并发编程，这会让编程难度进一步提高，因此人们提出了`Reactor`模式（即反应式编程）来解决异步并发编程的复杂性，那么反应式编程是如何处理这样的复杂型的呢？反应式编程提出了两种抽象：数据流和函数式编程。

函数式编程其实和数据流往往是不分离的，即函数式编程往往是建立在数据流上的，想想一个从输入源到输出源的“流”，我们可以在中间加上各种各样的函数改变流的行为。函数式编程精髓的一点是它是一种声明式模式而不是常用的命令式模式，函数式编程只关注结果而不关注过程，而命令式编程则需要程序员处理每个细节过程。

那么为什么要使用反应式编程呢，我们可以从这份[反应式宣言](https://www.reactivemanifesto.org/)中找找答案，文中给出了响应式系统的架构图：
![](https://www.reactivemanifesto.org/images/reactive-traits.svg)
从图中可以看出响应式系统以事件驱动为基础提供了系统Elastic和Resilient的能力，从而保障了整个系统的响应性、扩展性和可维护性。

具体的说，反应式编程可以有如下优势：

- 可读性，声明式的描述方式更加直观，避免陷入Callback Hell，这也是为什么反应式编程采用了函数式风格而不是命令式的回调风格。
- 高层次并发抽象，使得异步编程更加简单。
- 可复用、松耦合的组件，提供各种高阶函数。
- 背压（back pressure），提供失败恢复策略，使得系统可以具有回弹性（Resilient）和弹性（Elastic）。

### 背压 back pressure
背压是反应式编程中的核心概念，背压是指生产者的生产速率高于消费者消费速率的时候，消费者可以向生产者反馈，让生产者降低生产速率，这有点像自动控制领域里的负反馈控制，即把输出端的信息传递会输入端，输入端根据输出端的信息调整输入信号。
具体来讲，消费者这里可以有一个缓冲池，当缓冲池快要满的时候（比如接近75%），就要求生产者降低生产速率，同时还可以添加消费者线程，增加消费速率。
正因为背压这个思路，响应式系统具有较好的可伸缩性。


### 粘包与拆包
非阻塞编程这一块概念比较多、比较杂，但其实只需要拆开一个个看，就发现其实每个概念都不复杂。粘包和拆包在网络传输数据包的时候发生的问题：
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20230305180829.png)
当两个数据包之间没有间隙的时候就成为粘包，但两个数据包粘在一起会有什么问题呢？这是因为我们当前的编程环境都是数据流式的编程，从程序角度来看，数据源是一个源源不断发送数据的地方，因此程序需要知道一个包从什么时候开始什么时候结束，如果一个包前后都没有数据，那自然很好区分，但如果两个包粘在一起，就需要相应的逻辑来区分两个包的间隙。
另外，由于TCP传输一个数据包有大小上线（MTU一般是1500），因此一个包可能会被拆分成多个小块，程序应当有把多个小块合并成原始包的能力。

粘包和拆包这方面的逻辑往往由底层NIO框架处理，我们往往不需要处理这些细节。



### Reactive Stream API
JDK 9专门提供了针对反应式编程的模块[java.util.concurrent.Flow](https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html)，官方针对这个包有以下的描述：
>These interfaces correspond to the reactive-streams specification. They apply in both concurrent and distributed asynchronous settings: All (seven) methods are defined in void "one-way" message style. Communication relies on a simple form of flow control (method Flow.Subscription.request(long)) that can be used to avoid resource management problems that may otherwise occur in "push" based systems. 

上面的描述提到了这个包的关键点`Flow.Subscription.request(long)`，这个方法被消费者用来协调生产者的生产速率，实现所谓背压back pressure。

这个包一共只有四个接口：

- Publisher，发布者，可以发布无限序列的消息，可以根据订阅者的需求push消息，在任意时间点都可以动态服务多个订阅者，其接口如下：

```java
public interface Publisher<T> {

    /**
     * 请求发布者开始发布消息
     * 可以被多次调用，每次调用相互独立，会新建一个Subscription(发布订阅上下文)
     * 每个Subscription只服务一个Subscriber
     * 一个Subscriber只能subscribe一个Publisher
     * 如果Publisher拒绝此次订阅或者订阅失败会触发onError回调
     */
    public void subscribe(Subscriber<? super T> s);
}
```

- Subscriber，订阅者，消费发布者发布的消息，可以进行订阅、消费消息、接收完成、接收错误等动作，其接口如下：

```java
public interface Subscriber<T> {

    /**
     * 当调用Publisher.subcribe(Subscriber)时会被触发
     * Subscriber负责进行Subscription.request(long)调用，只有这个调用发生时才会开始真正的数据流
     * Publisher只会响应Subscription.request(long)操作
     */
    public void onSubscribe(Subscription s);

    /**
     * Publisher在接收到Subscription.request(long)调用时，通知订阅者进行消费
     */
    public void onNext(T t);

    /**
     * 失败终止状态通知
     */
    public void onError(Throwable t);

    /**
     * 成功终止状态通知
     */
    public void onComplete();
}
```

- Subscription，表示一个订阅者订阅发布者的上下文，用于控制数据交换，可以请求或者取消数据交换，其接口如下：

```java
public interface Subscription {

    /**
     * 只有当此方法被调用时，发布者才会发布消息
     * 发布者只可以发布小于等于请求的数据量以保证安全性
     */ 
    public void request(long n);

    /**
     * 通知发布者停止发布数据并清理相关资源
     * 发布者不会立即停止发布数据，会等到上一次请求的数据量发布完成后结束
     */ 
    public void cancel();
}
```

- Processor，表示发布者和订阅者之间数据处理的阶段，可以看成是发布者和订阅者之间的管道，其接口如下：

```java
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```
使用这四个接口可以很方便的写出响应式风格的程序，[这里](https://www.cnblogs.com/duanxz/p/14838586.html)有一个小的demo可供学习。




### Netty
Java在1.5版本中加入了异步编程接口，但是直接使用NIO编程比较复杂，而且还需要考虑粘包、半包传输等问题，于是Netty就出现了，Netty是一个基于Java的网络编程框架，它提供了一组易于使用的API，用于快速开发可扩展的、高性能的网络应用程序。Netty的主要目标是简化网络编程，提高应用程序的性能和可维护性。

Netty具有以下特点：

- 高性能：Netty的底层实现使用了一系列优化技术，如零拷贝、内存池等，以提高性能和减少资源消耗。
- 灵活性：Netty支持多种协议和传输方式，包括TCP、UDP、HTTP、WebSocket等，可以满足不同应用的需求。
- 可扩展性：Netty的设计支持自定义的编解码器和处理器，使得应用程序可以灵活地扩展功能。
- 易用性：Netty提供了简单易用的API和文档，使得开发者可以快速地上手使用。
- 多样化的应用场景：Netty适用于各种网络应用场景，如高性能的网络服务器、实时通信系统、分布式系统等。

下面是一段使用Netty异步IO的echo服务器代码
```java
public class EchoServer {

    public static void main(String[] args) throws Exception {
        // 创建EventLoopGroup，用于处理客户端连接和数据读写
        NioEventLoopGroup group = new NioEventLoopGroup();

        try {
            // 创建ServerBootstrap，用于启动服务器
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(group)
                .channel(NioServerSocketChannel.class)
                .localAddress(8888)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    public void initChannel(SocketChannel ch) {
                        ChannelPipeline pipeline = ch.pipeline();
                        pipeline.addLast(new EchoServerHandler());
                    }
                });

            // 绑定端口，开始接收连接
            ChannelFuture future = bootstrap.bind().sync();
            System.out.println("Echo server started and listening on " + future.channel().localAddress());

            // 等待服务器 socket 关闭
            future.channel().closeFuture().sync();
        } finally {
            // 释放所有资源
            group.shutdownGracefully().sync();
        }
    }

    public static class EchoServerHandler extends SimpleChannelInboundHandler<String> {
        @Override
        protected void channelRead0(ChannelHandlerContext ctx, String msg) {
            // 接收到消息，将其原样返回
            ctx.writeAndFlush(msg);
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
            // 发生异常，关闭连接
            cause.printStackTrace();
            ctx.close();
        }
    }
}
```


### Servlet 3.0
Servlet在3.0版本的时候提供了异步Servlet，下面是使用Svelte异步IO编程的一段echo服务器示例程序：
```java
@WebServlet(urlPatterns = "/echo", asyncSupported = true)
public class EchoServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        AsyncContext asyncContext = request.startAsync();
        ServletInputStream input = request.getInputStream();
        ServletOutputStream output = response.getOutputStream();

        input.setReadListener(new ReadListener() {
            byte[] buffer = new byte[1024];

            @Override
            public void onDataAvailable() throws IOException {
                while (input.isReady()) {
                    int length = input.read(buffer);
                    if (length > 0) {
                        output.write(buffer, 0, length);
                    }
                }
            }

            @Override
            public void onAllDataRead() throws IOException {
                asyncContext.complete();
            }

            @Override
            public void onError(Throwable t) {
                asyncContext.complete();
                t.printStackTrace();
            }
        });
    }
}
```
这段代码创建了一个异步Servlet，使用了`@WebServlet`注解来声明Servlet，指定了异步支持。当收到GET请求时，创建`AsyncContext`对象，并获取`ServletInputStream`和`ServletOutputStream`对象。接着，设置`ReadListener`对象，它会监听输入流中的数据，并将其写入输出流中。当输入流中没有数据可读时，`onAllDataRead`方法会被调用，该方法用于通知Servlet请求已经处理完毕。如果在处理请求的过程中出现了异常，`onError`方法会被调用，此时也需要调用`complete`方法来通知Servlet请求已经处理完毕。


### WebFlux
由于响应式编程和原来的命令式编程已经有很大的不同了，原来运行在`Servlet`同步IO下的Spring MVC已经不能适用响应式编程了，于是Spring开发出了新的一套web编程框架：`Reactive Stack`，其中的`Spring WebFlux`就是对应架构下的`Spring MVC`。
Reactive Stack的[官方文档](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux)中有很详细的关于响应式编程的内容，很推荐阅读。

讲到这里终于把WebFlux引入了，而Spring Cloud Gateway就是一个典型的WebFlux项目，Reactive Stack是保证网关的高并发需求的合适选择，作为响应式编程的践行者和推广者，Spring确实很适合开发一个网关项目，这个网关项目中将包含大量WebFlux基础接口的应用。


## Spring Cloud Gateway源码


## 参考资料
反应式宣言 https://www.reactivemanifesto.org/
使用Reactor进行反应式编程 https://t1mek1ller.github.io/2020/04/07/reactive-prgramming-reactor/
Reactor指南中文版  https://xy2401.com/local-docs/oschina/Reactor+指南中文版_V2.0.html
Reactive Stack 官方文档 https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html
